// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: venue.sql

package sqlc

import (
	"context"

	zero "gopkg.in/guregu/null.v4/zero"
)

const countVenues = `-- name: CountVenues :one
SELECT COUNT(*) FROM venues WHERE deleted_at IS NULL
`

func (q *Queries) CountVenues(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countVenues)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createVenue = `-- name: CreateVenue :exec
INSERT INTO venues (title, slug, venue_id, logo_url, status, description) VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateVenueParams struct {
	Title       string      `json:"title"`
	Slug        string      `json:"slug"`
	VenueID     zero.String `json:"venue_id"`
	LogoUrl     zero.String `json:"logo_url"`
	Status      bool        `json:"status"`
	Description zero.String `json:"description"`
}

func (q *Queries) CreateVenue(ctx context.Context, arg CreateVenueParams) error {
	_, err := q.db.Exec(ctx, createVenue,
		arg.Title,
		arg.Slug,
		arg.VenueID,
		arg.LogoUrl,
		arg.Status,
		arg.Description,
	)
	return err
}

const deleteVenue = `-- name: DeleteVenue :exec
DELETE FROM venues WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteVenue(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteVenue, id)
	return err
}

const existVenue = `-- name: ExistVenue :one
SELECT EXISTS(SELECT 1 FROM venues WHERE id = $1 AND deleted_at IS NULL)
`

func (q *Queries) ExistVenue(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRow(ctx, existVenue, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getVenue = `-- name: GetVenue :one
SELECT id, title, slug, venue_id, logo_url, status, description, created_at, deleted_at FROM venues WHERE id = $1 LIMIT 1 AND deleted_at IS NULL
`

func (q *Queries) GetVenue(ctx context.Context, id string) (Venue, error) {
	row := q.db.QueryRow(ctx, getVenue, id)
	var i Venue
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.VenueID,
		&i.LogoUrl,
		&i.Status,
		&i.Description,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listVenues = `-- name: ListVenues :many
SELECT id, title, slug, venue_id, logo_url, status, description, created_at, deleted_at FROM venues WHERE deleted_at IS NULL ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListVenuesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListVenues(ctx context.Context, arg ListVenuesParams) ([]Venue, error) {
	rows, err := q.db.Query(ctx, listVenues, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Venue
	for rows.Next() {
		var i Venue
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.VenueID,
			&i.LogoUrl,
			&i.Status,
			&i.Description,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVenue = `-- name: UpdateVenue :exec
UPDATE venues SET 
    title = COALESCE($1, title),
    slug = COALESCE($2, slug),
    venue_id = COALESCE($3, venue_id),
    logo_url = COALESCE($4, logo_url),
    status = COALESCE($5, status),
    description = COALESCE($6, description)
WHERE id = $7 AND deleted_at IS NULL
`

type UpdateVenueParams struct {
	Title       zero.String `json:"title"`
	Slug        zero.String `json:"slug"`
	VenueID     zero.String `json:"venue_id"`
	LogoUrl     zero.String `json:"logo_url"`
	Status      zero.Bool   `json:"status"`
	Description zero.String `json:"description"`
	ID          string      `json:"id"`
}

func (q *Queries) UpdateVenue(ctx context.Context, arg UpdateVenueParams) error {
	_, err := q.db.Exec(ctx, updateVenue,
		arg.Title,
		arg.Slug,
		arg.VenueID,
		arg.LogoUrl,
		arg.Status,
		arg.Description,
		arg.ID,
	)
	return err
}
